{"version":3,"file":"js/926.2fc74960.js","mappings":"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","sources":["webpack://test/./node_modules/observable-slim/observable-slim.js","webpack://test/./src/node-tree/editor/index.ts","webpack://test/./node_modules/vue-loader/dist/exportHelper.js","webpack://test/./src/node-tree/walker/index.vue?0bab","webpack://test/./src/node-tree/create-tree-api/injection-key.ts","webpack://test/./src/node-tree/walker/setup.ts","webpack://test/./src/node-tree/walker/index.vue?706e","webpack://test/./src/node-tree/walker/index.vue","webpack://test/./src/node-tree/create-tree-api/add.ts","webpack://test/./src/node-tree/create-tree-api/remove.ts","webpack://test/./src/node-tree/create-tree-api/clone.ts","webpack://test/./src/node-tree/create-tree-api/replace.ts","webpack://test/./src/node-tree/create-tree-api/move.ts","webpack://test/./src/node-tree/create-tree-api/schema.ts","webpack://test/./src/node-tree/create-tree-api/edit-fields.ts","webpack://test/./src/node-tree/create-tree-api/crud.ts","webpack://test/./src/node-tree/create-tree-api/index.ts","webpack://test/./src/node-tree/root/index.vue?7a97","webpack://test/./src/node-tree/root/index.vue"],"sourcesContent":["/*\r\n * \tObservable Slim\r\n *\tVersion 0.1.6\r\n * \thttps://github.com/elliotnb/observable-slim\r\n *\r\n * \tLicensed under the MIT license:\r\n * \thttp://www.opensource.org/licenses/MIT\r\n *\r\n *\tObservable Slim is a singleton that allows you to observe changes made to an object and any nested\r\n *\tchildren of that object. It is intended to assist with one-way data binding, that is, in MVC parlance,\r\n *\treflecting changes in the model to the view. Observable Slim aspires to be as lightweight and easily\r\n *\tunderstood as possible. Minifies down to roughly 3000 characters.\r\n */\r\nvar ObservableSlim = (function() {\r\n\tvar paths = [];\r\n\t// An array that stores all of the observables created through the public create() method below.\r\n\tvar observables = [];\r\n\t// An array of all the objects that we have assigned Proxies to\r\n\tvar targets = [];\r\n\r\n\t// An array of arrays containing the Proxies created for each target object. targetsProxy is index-matched with\r\n\t// 'targets' -- together, the pair offer a Hash table where the key is not a string nor number, but the actual target object\r\n\tvar targetsProxy = [];\r\n\r\n\t// this variable tracks duplicate proxies assigned to the same target.\r\n\t// the 'set' handler below will trigger the same change on all other Proxies tracking the same target.\r\n\t// however, in order to avoid an infinite loop of Proxies triggering and re-triggering one another, we use dupProxy\r\n\t// to track that a given Proxy was modified from the 'set' handler\r\n\tvar dupProxy = null;\r\n\r\n\tvar _getProperty = function(obj, path) {\r\n\t\treturn path.split('.').reduce(function(prev, curr) {\r\n\t\t\treturn prev ? prev[curr] : undefined\r\n\t\t}, obj || self)\r\n\t};\r\n\r\n\t/**\r\n\t * Create a new ES6 `Proxy` whose changes we can observe through the `observe()` method.\r\n\t * @param {object} target Plain object that we want to observe for changes.\r\n\t * @param {boolean|number} domDelay If `true`, then the observed changes to `target` will be batched up on a 10ms delay (via `setTimeout()`).\r\n\t * If `false`, then the `observer` function will be immediately invoked after each individual change made to `target`. It is helpful to set\r\n\t * `domDelay` to `true` when your `observer` function makes DOM manipulations (fewer DOM redraws means better performance). If a number greater\r\n\t * than zero, then it defines the DOM delay in milliseconds.\r\n\t * @param {function(ObservableSlimChange[])} [observer] Function that will be invoked when a change is made to the proxy of `target`.\r\n\t * When invoked, this function is passed a single argument: an array of `ObservableSlimChange` detailing each change that has been made.\r\n\t * @param {object} originalObservable The original observable created by the user, exists for recursion purposes, allows one observable to observe\r\n\t * change on any nested/child objects.\r\n\t * @param {{target: object, property: string}[]} originalPath Array of objects, each object having the properties `target` and `property`:\r\n\t * `target` is referring to the observed object itself and `property` referring to the name of that object in the nested structure.\r\n\t * The path of the property in relation to the target on the original observable, exists for recursion purposes, allows one observable to observe\r\n\t * change on any nested/child objects.\r\n\t * @returns {ProxyConstructor} Proxy of the target object.\r\n\t */\r\n\tvar _create = function(target, domDelay, originalObservable, originalPath) {\r\n\r\n\t\tvar observable = originalObservable || null;\r\n\r\n\t\t// record the nested path taken to access this object -- if there was no path then we provide the first empty entry\r\n\t\tvar path = originalPath || [{\"target\":target,\"property\":\"\"}];\r\n\t\tpaths.push(path);\r\n\r\n\t\t// in order to accurately report the \"previous value\" of the \"length\" property on an Array\r\n\t\t// we must use a helper property because intercepting a length change is not always possible as of 8/13/2018 in\r\n\t\t// Chrome -- the new `length` value is already set by the time the `set` handler is invoked\r\n\t\tif (target instanceof Array) {\r\n\t\t\tif (!target.hasOwnProperty(\"__length\"))\r\n\t\t\t\tObject.defineProperty(target, \"__length\", { enumerable: false, value: target.length, writable: true });\r\n\t\t\telse\r\n\t\t\t\ttarget.__length = target.length;\r\n\t\t}\r\n\r\n\t\tvar changes = [];\r\n\r\n\t\t/**\r\n\t\t * Returns a string of the nested path (in relation to the top-level observed object) of the property being modified or deleted.\r\n\t\t * @param {object} target Plain object that we want to observe for changes.\r\n\t\t * @param {string} property Property name.\r\n\t\t * @param {boolean} [jsonPointer] Set to `true` if the string path should be formatted as a JSON pointer rather than with the dot notation\r\n\t\t * (`false` as default).\r\n\t\t * @returns {string} Nested path (e.g., `hello.testing.1.bar` or, if JSON pointer, `/hello/testing/1/bar`).\r\n\t\t */\r\n\t\tvar _getPath = function(target, property, jsonPointer) {\r\n\r\n\t\t\tvar fullPath = \"\";\r\n\t\t\tvar lastTarget = null;\r\n\r\n\t\t\t// loop over each item in the path and append it to full path\r\n\t\t\tfor (var i = 0; i < path.length; i++) {\r\n\r\n\t\t\t\t// if the current object was a member of an array, it's possible that the array was at one point\r\n\t\t\t\t// mutated and would cause the position of the current object in that array to change. we perform an indexOf\r\n\t\t\t\t// lookup here to determine the current position of that object in the array before we add it to fullPath\r\n\t\t\t\tif (lastTarget instanceof Array && !isNaN(path[i].property)) {\r\n\t\t\t\t\tpath[i].property = lastTarget.indexOf(path[i].target);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfullPath = fullPath + \".\" + path[i].property\r\n\t\t\t\tlastTarget = path[i].target;\r\n\t\t\t}\r\n\r\n\t\t\t// add the current property\r\n\t\t\tfullPath = fullPath + \".\" + property;\r\n\r\n\t\t\t// remove the beginning two dots -- ..foo.bar becomes foo.bar (the first item in the nested chain doesn't have a property name)\r\n\t\t\tfullPath = fullPath.substring(2);\r\n\r\n\t\t\tif (jsonPointer === true) fullPath = \"/\" + fullPath.replace(/\\./g, \"/\");\r\n\r\n\t\t\treturn fullPath;\r\n\t\t};\r\n\r\n\t\tvar _notifyObservers = function(numChanges) {\r\n\r\n\t\t\t// if the observable is paused, then we don't want to execute any of the observer functions\r\n\t\t\tif (observable.paused === true) return;\r\n\r\n\t\t\tvar domDelayIsNumber = typeof domDelay === 'number';\r\n\r\n\t\t\t// execute observer functions on a 10ms setTimeout, this prevents the observer functions from being executed\r\n\t\t\t// separately on every change -- this is necessary because the observer functions will often trigger UI updates\r\n \t\t\tif (domDelayIsNumber || domDelay === true) {\r\n\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\tif (numChanges === changes.length) {\r\n\r\n\t\t\t\t\t\t// we create a copy of changes before passing it to the observer functions because even if the observer function\r\n\t\t\t\t\t\t// throws an error, we still need to ensure that changes is reset to an empty array so that old changes don't persist\r\n\t\t\t\t\t\tvar changesCopy = changes.slice(0);\r\n\t\t\t\t\t\tchanges = [];\r\n\r\n\t\t\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changesCopy);\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}, (domDelayIsNumber && domDelay > 0) ? domDelay : 10);\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// we create a copy of changes before passing it to the observer functions because even if the observer function\r\n\t\t\t\t// throws an error, we still need to ensure that changes is reset to an empty array so that old changes don't persist\r\n\t\t\t\tvar changesCopy = changes.slice(0);\r\n\t\t\t\tchanges = [];\r\n\r\n\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changesCopy);\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar handler = {\r\n\t\t\tget: function(target, property) {\r\n\r\n\t\t\t\t// implement a simple check for whether or not the object is a proxy, this helps the .create() method avoid\r\n\t\t\t\t// creating Proxies of Proxies.\r\n\t\t\t\tif (property === \"__getTarget\") {\r\n\t\t\t\t\treturn target;\r\n\t\t\t\t} else if (property === \"__isProxy\") {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t// from the perspective of a given observable on a parent object, return the parent object of the given nested object\r\n\t\t\t\t} else if (property === \"__getParent\") {\r\n\t\t\t\t\treturn function(i) {\r\n\t\t\t\t\t\tif (typeof i === \"undefined\") var i = 1;\r\n\t\t\t\t\t\tvar parentPath = _getPath(target, \"__getParent\").split(\".\");\r\n\t\t\t\t\t\tparentPath.splice(-(i+1),(i+1));\r\n\t\t\t\t\t\treturn _getProperty(observable.parentProxy, parentPath.join(\".\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t// return the full path of the current object relative to the parent observable\r\n\t\t\t\t} else if (property === \"__getPath\") {\r\n\t\t\t\t\t// strip off the 12 characters for \".__getParent\"\r\n\t\t\t\t\tvar parentPath = _getPath(target, \"__getParent\");\r\n\t\t\t\t\treturn parentPath.slice(0, -12);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// for performance improvements, we assign this to a variable so we do not have to lookup the property value again\r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\tif (target instanceof Date && targetProp instanceof Function && targetProp !== null) {\r\n\t\t\t\t\treturn targetProp.bind(target);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if we are traversing into a new object, then we want to record path to that object and return a new observable.\r\n\t\t\t\t// recursively returning a new observable allows us a single Observable.observe() to monitor all changes on\r\n\t\t\t\t// the target object and any objects nested within.\r\n\t\t\t\tif (targetProp instanceof Object && targetProp !== null && target.hasOwnProperty(property)) {\r\n\r\n\t\t\t\t\t// if we've found a proxy nested on the object, then we want to retrieve the original object behind that proxy\r\n\t\t\t\t\tif (targetProp.__isProxy === true) targetProp = targetProp.__getTarget;\r\n\r\n\t\t\t\t\t// if the object accessed by the user (targetProp) already has a __targetPosition AND the object\r\n\t\t\t\t\t// stored at target[targetProp.__targetPosition] is not null, then that means we are already observing this object\r\n\t\t\t\t\t// we might be able to return a proxy that we've already created for the object\r\n\t\t\t\t\tif (targetProp.__targetPosition > -1 && targets[targetProp.__targetPosition] !== null) {\r\n\r\n\t\t\t\t\t\t// loop over the proxies that we've created for this object\r\n\t\t\t\t\t\tvar ttp = targetsProxy[targetProp.__targetPosition];\r\n\t\t\t\t\t\tfor (var i = 0, l = ttp.length; i < l; i++) {\r\n\r\n\t\t\t\t\t\t\t// if we find a proxy that was setup for this particular observable, then return that proxy\r\n\t\t\t\t\t\t\tif (observable === ttp[i].observable) {\r\n\t\t\t\t\t\t\t\treturn ttp[i].proxy;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if we're arrived here, then that means there is no proxy for the object the user just accessed, so we\r\n\t\t\t\t\t// have to create a new proxy for it\r\n\r\n\t\t\t\t\t// create a shallow copy of the path array -- if we didn't create a shallow copy then all nested objects would share the same path array and the path wouldn't be accurate\r\n\t\t\t\t\tvar newPath = path.slice(0);\r\n\t\t\t\t\tnewPath.push({\"target\":targetProp,\"property\":property});\r\n\t\t\t\t\treturn _create(targetProp, domDelay, observable, newPath);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn targetProp;\r\n\t\t\t\t}\r\n\t\t\t},\r\n \t\t\tdeleteProperty: function(target, property) {\r\n\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in order to report what the previous value was, we must make a copy of it before it is deleted\r\n\t\t\t\tvar previousValue = Object.assign({}, target);\r\n\r\n\t\t\t\t// record the deletion that just took place\r\n\t\t\t\tchanges.push({\r\n\t\t\t\t\t\"type\":\"delete\"\r\n\t\t\t\t\t,\"target\":target\r\n\t\t\t\t\t,\"property\":property\r\n\t\t\t\t\t,\"newValue\":null\r\n\t\t\t\t\t,\"previousValue\":previousValue[property]\r\n\t\t\t\t\t,\"currentPath\":_getPath(target, property)\r\n\t\t\t\t\t,\"jsonPointer\":_getPath(target, property, true)\r\n\t\t\t\t\t,\"proxy\":proxy\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (originalChange === true) {\r\n\r\n\t\t\t\t\t// perform the delete that we've trapped if changes are not paused for this observable\r\n\t\t\t\t\tif (!observable.changesPaused) delete target[property];\r\n\r\n\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\r\n\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\tvar currentTargetProxy = targetsProxy[a] || [];\r\n\r\n\t\t\t\t\tvar b = currentTargetProxy.length;\r\n\t\t\t\t\twhile (b--) {\r\n\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\r\n\t\t\t\t\t\t\t// make the same delete on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\tdelete currentTargetProxy[b].proxy[property];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_notifyObservers(changes.length);\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t},\r\n\t\t\tset: function(target, property, value, receiver) {\r\n\r\n\t\t\t\t// if the value we're assigning is an object, then we want to ensure\r\n\t\t\t\t// that we're assigning the original object, not the proxy, in order to avoid mixing\r\n\t\t\t\t// the actual targets and proxies -- creates issues with path logging if we don't do this\r\n\t\t\t\tif (value && value.__isProxy) value = value.__getTarget;\r\n\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// improve performance by saving direct references to the property\r\n\t\t\t\tvar targetProp = target[property];\r\n\r\n\t\t\t\t// Only record this change if:\r\n\t\t\t\t// \t1. the new value differs from the old one\r\n\t\t\t\t//\t2. OR if this proxy was not the original proxy to receive the change\r\n\t\t\t\t// \t3. OR the modified target is an array and the modified property is \"length\" and our helper property __length indicates that the array length has changed\r\n\t\t\t\t//\r\n\t\t\t\t// Regarding #3 above: mutations of arrays via .push or .splice actually modify the .length before the set handler is invoked\r\n\t\t\t\t// so in order to accurately report the correct previousValue for the .length, we have to use a helper property.\r\n\t\t\t\tif (targetProp !== value || originalChange === false || (property === \"length\" && target instanceof Array && target.__length !== value)) {\r\n\r\n\t\t\t\t\tvar foundObservable = true;\r\n\r\n\t\t\t\t\tvar typeOfTargetProp = (typeof targetProp);\r\n\r\n\t\t\t\t\t// determine if we're adding something new or modifying some that already existed\r\n\t\t\t\t\tvar type = \"update\";\r\n\t\t\t\t\tif (typeOfTargetProp === \"undefined\") type = \"add\";\r\n\r\n\t\t\t\t\t// store the change that just occurred. it is important that we store the change before invoking the other proxies so that the previousValue is correct\r\n\t\t\t\t\tchanges.push({\r\n\t\t\t\t\t\t\"type\":type\r\n\t\t\t\t\t\t,\"target\":target\r\n\t\t\t\t\t\t,\"property\":property\r\n\t\t\t\t\t\t,\"newValue\":value\r\n\t\t\t\t\t\t,\"previousValue\":receiver[property]\r\n\t\t\t\t\t\t,\"currentPath\":_getPath(target, property)\r\n\t\t\t\t\t\t,\"jsonPointer\":_getPath(target, property, true)\r\n\t\t\t\t\t\t,\"proxy\":proxy\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// mutations of arrays via .push or .splice actually modify the .length before the set handler is invoked\r\n\t\t\t\t\t// so in order to accurately report the correct previousValue for the .length, we have to use a helper property.\r\n\t\t\t\t\tif (property === \"length\" && target instanceof Array && target.__length !== value) {\r\n\t\t\t\t\t\tchanges[changes.length-1].previousValue = target.__length;\r\n\t\t\t\t\t\ttarget.__length = value;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// !!IMPORTANT!! if this proxy was the first proxy to receive the change, then we need to go check and see\r\n\t\t\t\t\t// if there are other proxies for the same project. if there are, then we will modify those proxies as well so the other\r\n\t\t\t\t\t// observers can be modified of the change that has occurred.\r\n\t\t\t\t\tif (originalChange === true) {\r\n\r\n\t\t\t\t\t\t// because the value actually differs than the previous value\r\n\t\t\t\t\t\t// we need to store the new value on the original target object,\r\n\t\t\t\t\t\t// but only as long as changes have not been paused\r\n\t\t\t\t\t\tif (!observable.changesPaused) target[property] = value;\r\n\r\n\r\n\t\t\t\t\t\tfoundObservable = false;\r\n\r\n\t\t\t\t\t\tvar targetPosition = target.__targetPosition;\r\n\t\t\t\t\t\tvar z = targetsProxy[targetPosition].length;\r\n\r\n\t\t\t\t\t\t// find the parent target for this observable -- if the target for that observable has not been removed\r\n\t\t\t\t\t\t// from the targets array, then that means the observable is still active and we should notify the observers of this change\r\n\t\t\t\t\t\twhile (z--) {\r\n\t\t\t\t\t\t\tif (observable === targetsProxy[targetPosition][z].observable) {\r\n\t\t\t\t\t\t\t\tif (targets[targetsProxy[targetPosition][z].observable.parentTarget.__targetPosition] !== null) {\r\n\t\t\t\t\t\t\t\t\tfoundObservable = true;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we didn't find an observable for this proxy, then that means .remove(proxy) was likely invoked\r\n\t\t\t\t\t\t// so we no longer need to notify any observer function about the changes, but we still need to update the\r\n\t\t\t\t\t\t// value of the underlying original objects see below: target[property] = value;\r\n\t\t\t\t\t\tif (foundObservable) {\r\n\r\n\t\t\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[targetPosition];\r\n\t\t\t\t\t\t\tfor (var b = 0, l = currentTargetProxy.length; b < l; b++) {\r\n\t\t\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\r\n\t\t\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\r\n\t\t\t\t\t\t\t\t\t// invoke the same change on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\t\t\tcurrentTargetProxy[b].proxy[property] = value;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// if the property being overwritten is an object, then that means this observable\r\n\t\t\t\t\t\t\t// will need to stop monitoring this object and any nested objects underneath the overwritten object else they'll become\r\n\t\t\t\t\t\t\t// orphaned and grow memory usage. we execute this on a setTimeout so that the clean-up process does not block\r\n\t\t\t\t\t\t\t// the UI rendering -- there's no need to execute the clean up immediately\r\n\t\t\t\t\t\t\tsetTimeout(function() {\r\n\r\n\t\t\t\t\t\t\t\tif (typeOfTargetProp === \"object\" && targetProp !== null) {\r\n\r\n\t\t\t\t\t\t\t\t\t// check if the to-be-overwritten target property still exists on the target object\r\n\t\t\t\t\t\t\t\t\t// if it does still exist on the object, then we don't want to stop observing it. this resolves\r\n\t\t\t\t\t\t\t\t\t// an issue where array .sort() triggers objects to be overwritten, but instead of being overwritten\r\n\t\t\t\t\t\t\t\t\t// and discarded, they are shuffled to a new position in the array\r\n\t\t\t\t\t\t\t\t\tvar keys = Object.keys(target);\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif (target[keys[i]] === targetProp) return;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tvar stillExists = false;\r\n\r\n\t\t\t\t\t\t\t\t\t// now we perform the more expensive search recursively through the target object.\r\n\t\t\t\t\t\t\t\t\t// if we find the targetProp (that was just overwritten) still exists somewhere else\r\n\t\t\t\t\t\t\t\t\t// further down in the object, then we still need to observe the targetProp on this observable.\r\n\t\t\t\t\t\t\t\t\t(function iterate(target) {\r\n\t\t\t\t\t\t\t\t\t\tvar keys = Object.keys(target);\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\t\t\t\t\t\t\tvar nestedTarget = target[property];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (nestedTarget instanceof Object && nestedTarget !== null) iterate(nestedTarget);\r\n\t\t\t\t\t\t\t\t\t\t\tif (nestedTarget === targetProp) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tstillExists = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t})(target);\r\n\r\n\t\t\t\t\t\t\t\t\t// even though targetProp was overwritten, if it still exists somewhere else on the object,\r\n\t\t\t\t\t\t\t\t\t// then we don't want to remove the observable for that object (targetProp)\r\n\t\t\t\t\t\t\t\t\tif (stillExists === true) return;\r\n\r\n\t\t\t\t\t\t\t\t\t// loop over each property and recursively invoke the `iterate` function for any\r\n\t\t\t\t\t\t\t\t\t// objects nested on targetProp\r\n\t\t\t\t\t\t\t\t\t(function iterate(obj) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar keys = Object.keys(obj);\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar objProp = obj[keys[i]];\r\n\t\t\t\t\t\t\t\t\t\t\tif (objProp instanceof Object && objProp !== null) iterate(objProp);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// if there are any existing target objects (objects that we're already observing)...\r\n\t\t\t\t\t\t\t\t\t\tvar c = -1;\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (obj === targets[i]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tc = i;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (c > -1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// ...then we want to determine if the observables for that object match our current observable\r\n\t\t\t\t\t\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[c];\r\n\t\t\t\t\t\t\t\t\t\t\tvar d = currentTargetProxy.length;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\twhile (d--) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if we do have an observable monitoring the object thats about to be overwritten\r\n\t\t\t\t\t\t\t\t\t\t\t\t// then we can remove that observable from the target object\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (observable === currentTargetProxy[d].observable) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentTargetProxy.splice(d,1);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// if there are no more observables assigned to the target object, then we can remove\r\n\t\t\t\t\t\t\t\t\t\t\t// the target object altogether. this is necessary to prevent growing memory consumption particularly with large data sets\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentTargetProxy.length == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// targetsProxy.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t\t\ttargets[c] = null;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t})(targetProp)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},10000);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// TO DO: the next block of code resolves test case #29, but it results in poor IE11 performance with very large objects.\r\n\t\t\t\t\t\t// UPDATE: need to re-evaluate IE11 performance due to major performance overhaul from 12/23/2018.\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// if the value we've just set is an object, then we'll need to iterate over it in order to initialize the\r\n\t\t\t\t\t\t// observers/proxies on all nested children of the object\r\n\t\t\t\t\t\t/* if (value instanceof Object && value !== null) {\r\n\t\t\t\t\t\t\t(function iterate(proxy) {\r\n\t\t\t\t\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\t\t\t\t\tvar keys = Object.keys(target);\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t})(proxy[property]);\r\n\t\t\t\t\t\t}; */\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (foundObservable) {\r\n\t\t\t\t\t\t// notify the observer functions that the target has been modified\r\n\t\t\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar __targetPosition = target.__targetPosition;\r\n\t\tif (!(__targetPosition > -1)) {\r\n\t\t\tObject.defineProperty(target, \"__targetPosition\", {\r\n\t\t\t\tvalue: targets.length\r\n\t\t\t\t,writable: false\r\n\t\t\t\t,enumerable: false\r\n\t\t\t\t,configurable: false\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// create the proxy that we'll use to observe any changes\r\n\t\tvar proxy = new Proxy(target, handler);\r\n\r\n\t\t// we don't want to create a new observable if this function was invoked recursively\r\n\t\tif (observable === null) {\r\n\t\t\tobservable = {\"parentTarget\":target, \"domDelay\":domDelay, \"parentProxy\":proxy, \"observers\":[],\"paused\":false,\"path\":path,\"changesPaused\":false};\r\n\t\t\tobservables.push(observable);\r\n\t\t}\r\n\r\n\t\t// store the proxy we've created so it isn't re-created unnecessarily via get handler\r\n\t\tvar proxyItem = {\"target\":target,\"proxy\":proxy,\"observable\":observable};\r\n\r\n\t\t// if we have already created a Proxy for this target object then we add it to the corresponding array\r\n\t\t// on targetsProxy (targets and targetsProxy work together as a Hash table indexed by the actual target object).\r\n\t\tif (__targetPosition > -1) {\r\n\r\n\t\t\t// the targets array is set to null for the position of this particular object, then we know that\r\n\t\t\t// the observable was removed some point in time for this object -- so we need to set the reference again\r\n\t\t\tif (targets[__targetPosition] === null) {\r\n\t\t\t\ttargets[__targetPosition] = target;\r\n\t\t\t}\r\n\r\n\t\t\ttargetsProxy[__targetPosition].push(proxyItem);\r\n\r\n\t\t// else this is a target object that we had not yet created a Proxy for, so we must add it to targets,\r\n\t\t// and push a new array on to targetsProxy containing the new Proxy\r\n\t\t} else {\r\n\t\t\ttargets.push(target);\r\n\t\t\ttargetsProxy.push([proxyItem]);\r\n\t\t}\r\n\r\n\t\treturn proxy;\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {object} ObservableSlimChange Observed change.\r\n\t * @property {\"add\"|\"update\"|\"delete\"} type Change type.\r\n\t * @property {string} property Property name.\r\n\t * @property {string} currentPath Property path with the dot notation (e.g. `foo.0.bar`).\r\n\t * @property {string} jsonPointer Property path with the JSON pointer syntax (e.g. `/foo/0/bar`). See https://datatracker.ietf.org/doc/html/rfc6901.\r\n\t * @property {object} target Target object.\r\n\t * @property {ProxyConstructor} proxy Proxy of the target object.\r\n\t * @property {*} newValue New value of the property.\r\n\t * @property {*} [previousValue] Previous value of the property\r\n\t */\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Create a new ES6 `Proxy` whose changes we can observe through the `observe()` method.\r\n\t\t * @param {object} target Plain object that we want to observe for changes.\r\n\t\t * @param {boolean|number} domDelay If `true`, then the observed changes to `target` will be batched up on a 10ms delay (via `setTimeout()`).\r\n\t\t * If `false`, then the `observer` function will be immediately invoked after each individual change made to `target`. It is helpful to set\r\n\t\t * `domDelay` to `true` when your `observer` function makes DOM manipulations (fewer DOM redraws means better performance). If a number greater\r\n\t\t * than zero, then it defines the DOM delay in milliseconds.\r\n\t\t * @param {function(ObservableSlimChange[])} [observer] Function that will be invoked when a change is made to the proxy of `target`.\r\n\t\t * When invoked, this function is passed a single argument: an array of `ObservableSlimChange` detailing each change that has been made.\r\n\t\t * @returns {ProxyConstructor} Proxy of the target object.\r\n\t\t */\r\n\t\tcreate: function(target, domDelay, observer) {\r\n\r\n\t\t\t// test if the target is a Proxy, if it is then we need to retrieve the original object behind the Proxy.\r\n\t\t\t// we do not allow creating proxies of proxies because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\tif (target.__isProxy === true) {\r\n\t\t\t\tvar target = target.__getTarget;\r\n\t\t\t\t//if it is, then we should throw an error. we do not allow creating proxies of proxies\r\n\t\t\t\t// because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\t\t//throw new Error(\"ObservableSlim.create() cannot create a Proxy for a target object that is also a Proxy.\");\r\n\t\t\t}\r\n\r\n\t\t\t// fire off the _create() method -- it will create a new observable and proxy and return the proxy\r\n\t\t\tvar proxy = _create(target, domDelay);\r\n\r\n\t\t\t// assign the observer function\r\n\t\t\tif (typeof observer === \"function\") this.observe(proxy, observer);\r\n\r\n\t\t\t// recursively loop over all nested objects on the proxy we've just created\r\n\t\t\t// this will allow the top observable to observe any changes that occur on a nested object\r\n\t\t\t(function iterate(proxy) {\r\n\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\tvar keys  = Object.keys(target);\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t}\r\n\t\t\t})(proxy);\r\n\r\n\t\t\treturn proxy;\r\n\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Add a new observer function to an existing proxy.\r\n\t\t * @param {ProxyConstructor} proxy An ES6 `Proxy` created by the `create()` method.\r\n\t\t * @param {function(ObservableSlimChange[])} observer Function that will be invoked when a change is made to the proxy of `target`.\r\n\t\t * When invoked, this function is passed a single argument: an array of `ObservableSlimChange` detailing each change that has been made.\r\n\t\t * @returns {void} Does not return any value.\r\n\t\t */\r\n\t\tobserve: function(proxy, observer) {\r\n\t\t\t// loop over all the observables created by the _create() function\r\n\t\t\tvar i = observables.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].observers.push(observer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Prevent any observer functions from being invoked when a change occurs to a proxy.\r\n\t\t * @param {ProxyConstructor} proxy An ES6 `Proxy` created by the `create()` method.\r\n\t\t * @returns {void} Does not return any value.\r\n\t\t */\r\n\t\tpause: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = true;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not pause observable -- matching proxy not found.\");\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Resume execution of any observer functions when a change is made to a proxy.\r\n\t\t * @param {ProxyConstructor} proxy An ES6 `Proxy` created by the `create()` method.\r\n\t\t * @returns {void} Does not return any value.\r\n\t\t */\r\n\t\tresume: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = false;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not resume observable -- matching proxy not found.\");\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Prevent any changes (i.e., `set`, and `deleteProperty`) from being written to the target object.\r\n\t\t * However, the observer functions will still be invoked to let you know what changes **WOULD** have been made.\r\n\t\t * This can be useful if the changes need to be approved by an external source before the changes take effect.\r\n\t\t * @param {ProxyConstructor} proxy An ES6 `Proxy` created by the `create()` method.\r\n\t\t * @returns {void} Does not return any value.\r\n\t\t */\r\n\t\tpauseChanges: function(proxy){\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].changesPaused = true;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not pause changes on observable -- matching proxy not found.\");\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Resume the changes that were taking place prior to the call to `pauseChanges()` method.\r\n\t\t * @param {ProxyConstructor} proxy An ES6 `Proxy` created by the `create()` method.\r\n\t\t * @returns {void} Does not return any value.\r\n\t\t */\r\n\t\tresumeChanges: function(proxy){\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].changesPaused = false;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not resume changes on observable -- matching proxy not found.\");\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove the observable and proxy thereby preventing any further callback observers for changes occurring to the target object.\r\n\t\t * @param {ProxyConstructor} proxy An ES6 `Proxy` created by the `create()` method.\r\n\t\t * @returns {void} Does not return any value.\r\n\t\t */\r\n\t\tremove: function(proxy) {\r\n\r\n\t\t\tvar matchedObservable = null;\r\n\t\t\tvar foundMatch = false;\r\n\r\n\t\t\tvar c = observables.length;\r\n\t\t\twhile (c--) {\r\n\t\t\t\tif (observables[c].parentProxy === proxy) {\r\n\t\t\t\t\tmatchedObservable = observables[c];\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tvar a = targetsProxy.length;\r\n\t\t\twhile (a--) {\r\n\t\t\t\tvar b = targetsProxy[a].length;\r\n\t\t\t\twhile (b--) {\r\n\t\t\t\t\tif (targetsProxy[a][b].observable === matchedObservable) {\r\n\t\t\t\t\t\ttargetsProxy[a].splice(b,1);\r\n\r\n\t\t\t\t\t\t// if there are no more proxies for this target object\r\n\t\t\t\t\t\t// then we null out the position for this object on the targets array\r\n\t\t\t\t\t\t// since we are essentially no longer observing this object.\r\n\t\t\t\t\t\t// we do not splice it off the targets array, because if we re-observe the same\r\n\t\t\t\t\t\t// object at a later time, the property __targetPosition cannot be redefined.\r\n\t\t\t\t\t\tif (targetsProxy[a].length === 0) {\r\n\t\t\t\t\t\t\ttargets[a] = null;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t};\r\n\r\n\t\t\tif (foundMatch === true) {\r\n\t\t\t\tobservables.splice(c,1);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n// Export in a try catch to prevent this from erroring out on older browsers\r\ntry { module.exports = ObservableSlim; } catch (err) {};\r\n","import { $pockets } from \"@/pockets\"\r\nimport type { TreeEditor } from \"@/node-tree/types\"\r\nimport { reactive, computed } from \"vue\"\r\n\r\nexport let editor:TreeEditor  = reactive( {\r\n\r\n    show: true,\r\n    mode: \"edit\",\r\n    \r\n    nodes: {\r\n        list: [],\r\n        fields: []\r\n    },\r\n    active: false,\r\n    selectedNodes: [],\r\n    save: () => $pockets.event.emit('pockets/node-tree/save'),\r\n    modeLocked: computed(() => {\r\n        if(editor.selectedNodes.length > 0) return true;\r\n    })\r\n\r\n} )\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n","import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, resolveDynamicComponent as _resolveDynamicComponent, createBlock as _createBlock, withModifiers as _withModifiers, mergeProps as _mergeProps, resolveDirective as _resolveDirective, withCtx as _withCtx, withDirectives as _withDirectives } from \"vue\"\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _directive_tooltip = _resolveDirective(\"tooltip\")!\n\n  return _withDirectives((_openBlock(), _createBlock(_resolveDynamicComponent(_ctx.treeNode.el), _mergeProps(_ctx.treeNode.props, {\n    class: [\"pockets-node-tree-node\", _ctx.classes],\n    onClick: _withModifiers(_ctx.clickHandler, [\"stop\"]),\n    onMouseenter: _cache[0] || (_cache[0] = ($event: any) => (_ctx.hoverHandler(true))),\n    onMouseleave: _cache[1] || (_cache[1] = ($event: any) => (_ctx.hoverHandler(false)))\n  }), {\n    default: _withCtx(() => [\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.treeNode.nodes, (node, i) => {\n        return (_openBlock(), _createBlock(_resolveDynamicComponent(\"tree-walker\"), {\n          \"tree-node\": node,\n          key: node.__targetPosition\n        }, null, 8, [\"tree-node\"]))\n      }), 128))\n    ]),\n    _: 1\n  }, 16, [\"onClick\", \"class\"])), [\n    [_directive_tooltip, _ctx.toolTip]\n  ])\n}","import { InjectionKey, inject } from \"vue\"\r\nimport type { createdApi } from '@/node-tree/types'\r\n\r\nexport let injectionKey: InjectionKey<createdApi> = Symbol('pockets-node-tree-api')\r\n\r\nexport let useInject = () => {\r\n  const resolved = inject(injectionKey);\r\n  if (!resolved) {\r\n    throw new Error(`Could not resolve Injection`);\r\n  }\r\n  return resolved;\r\n}","import { editor } from \"@/node-tree/editor/\"\r\nimport { computed, reactive } from \"vue\"\r\nimport { useInject } from \"@/node-tree/create-tree-api/injection-key\"\r\n\r\nexport let setup = (props) => {\r\n\r\n    let disabled = computed(() => {\r\n        if(state.selected && editor.mode == 'move') return true\r\n    })\r\n\r\n    let nodeApi = useInject().getNodeApi(props.treeNode)\r\n\r\n    let selected = computed( () =>  editor.selectedNodes.filter(e => e.paths.full == nodeApi.paths.full ).length > 0 )\r\n    \r\n    let childOfselected = computed( () =>  editor.selectedNodes.filter(e => {\r\n        if(nodeApi.paths.full.length == e.paths.full.length) return false;\r\n        return nodeApi.paths.full.includes(e.paths.full)\r\n    } ).length > 0 )\r\n    \r\n    let active = computed( () => {\r\n        if(!editor?.active ) return;\r\n        if(editor?.active?.paths.full == nodeApi.paths.full) return true\r\n    } )\r\n\r\n    let classes = computed( () => {\r\n        let {\r\n            active,\r\n            hovered,\r\n            selected\r\n        } = state\r\n        return {\r\n            hovered,\r\n            active,\r\n            \"editor-show\": editor.show,\r\n            \"selected\": selected && editor.show\r\n        }\r\n    } )\r\n\r\n    let toolTip = computed( () => ( {\r\n        content: nodeApi.branch.map(e => e.schema.title).join(' > '), \r\n        shown: editor?.show && state.hovered, \r\n        triggers: [], \r\n        placement: \"auto-start\", \r\n        popperClass: `pockets-node-tree-node-tooltip`,\r\n        delay: 1\r\n    } ) )\r\n\r\n    let hoverHandler = (value: boolean) => {\r\n        if(state.childOfselected || state.selected) return;\r\n        state.hovered = value\r\n    }\r\n\r\n    let clickHandler = () => {\r\n        if(!editor.show) return\r\n        if( state.childOfselected ) return;\r\n        return editor.active = nodeApi \r\n    }\r\n\r\n    let state = reactive( {\r\n        hovered: false,\r\n        disabled,\r\n        selected,\r\n        childOfselected,\r\n        active,\r\n        classes,\r\n        hoverHandler,\r\n        toolTip,\r\n        disableInteractions: childOfselected,\r\n        clickHandler,\r\n    } )\r\n\r\n    return state\r\n    \r\n}\r\n","\r\nimport { setup } from \"./setup\"\r\n\r\nlet props = {\r\n    treeNode: {\r\n        /**\r\n            This is an object so that the observableSlim proxy isn't lost\r\n        */\r\n        el: String,\r\n        data: Object,\r\n        nodes: {\r\n            type: Array,\r\n        },\r\n        props: Object,\r\n        schema: String,\r\n    },\r\n}\r\nexport default {\r\n    name: \"tree-walker\",\r\n    setup,\r\n    props\r\n}\r\n","import { render } from \"./index.vue?vue&type=template&id=cc3c8a2a&ts=true\"\nimport script from \"./index.vue?vue&type=script&lang=ts\"\nexport * from \"./index.vue?vue&type=script&lang=ts\"\n\nimport \"./index.vue?vue&type=style&index=0&id=cc3c8a2a&lang=scss\"\n\nimport exportComponent from \"C:\\\\Users\\\\Justin\\\\Documents\\\\Workspace\\\\xampp\\\\apps\\\\pockets\\\\htdocs\\\\wp-content\\\\plugins\\\\pockets\\\\vue\\\\dev\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { $pockets } from \"@/pockets\"\r\nimport type { add, TreeNode, TreeNodeApi } from \"@/node-tree/types\"\r\n\r\nexport let useAdd = (api: TreeNodeApi) : add => {\r\n\r\n    let inside = (node: TreeNode, index: number = 0) => {\r\n        if(api.node.nodes){\r\n            api.node.nodes.splice( index, 0, node )\r\n            return api.node.nodes[index]\r\n        }\r\n        return false\r\n    }\r\n\r\n    let after = (node: TreeNode) => {\r\n        if(!api.parent || !api.parent.add.inside) return false;\r\n        return api.parent.add.inside(node, api.paths.index + 1)\r\n    }\r\n\r\n    let before = (node: TreeNode) => {\r\n        if(!api.parent || !api.parent.add.inside) return false;\r\n        return api.parent.add.inside(node, api.paths.index)\r\n    }\r\n\r\n    let add:add = {\r\n        inside,\r\n        before,\r\n        after\r\n    }\r\n\r\n    if(!api.parent) {\r\n        Object.assign(add, { before: false, after: false } )\r\n    }\r\n    if(!api.hasNodes ) {\r\n        add.inside = false\r\n    }\r\n\r\n    return add\r\n\r\n}","import type { remove, TreeNodeApi } from \"@/node-tree/types\"\r\n\r\nexport let useRemove = (api:TreeNodeApi) : remove => {\r\n   \r\n    let child = (index: number) => {\r\n        if(api.node.nodes) {\r\n            api.node.nodes.splice(index, 1)\r\n        }\r\n        return false\r\n    }\r\n\r\n    let self = () => {\r\n        if(!api.parent || !api.parent.remove.child) return false;\r\n        api.parent.remove.child(api.paths.index)\r\n        return false\r\n    }\r\n\r\n    let remove:remove = {\r\n        self,\r\n        child\r\n    }\r\n    if(!api.parent) {\r\n        remove.self = false\r\n    }\r\n    if(!api.node.nodes) {\r\n        remove.child = false\r\n    }\r\n    \r\n    return remove\r\n}","import { $pockets } from \"@/pockets\"\r\nimport type { clone, TreeNodeApi } from \"@/node-tree/types\"\r\n\r\nexport let useClone = (api:TreeNodeApi) : clone => {\r\n    \r\n    let self = () => {\r\n        if(!api.parent || !api.parent.clone.child) return false;\r\n        return api.parent.clone.child(api.paths.index)\r\n    }\r\n    \r\n    let child = (index: number) => {\r\n        if(!api.add.inside) return false;\r\n        let child = api.getChild(index)\r\n        if(child.node) {\r\n            let targetIndex = index+1\r\n            api.add.inside( $pockets.utils.object.clone( child.node ), targetIndex )\r\n            if(api.node.nodes) {\r\n                return api.node.nodes[targetIndex]  \r\n            }\r\n        }\r\n        return false\r\n    }\r\n    let clone: clone = {\r\n        self,\r\n        child\r\n    }\r\n    if(!api.hasNodes){\r\n        clone.child = false\r\n    }\r\n    if(!api.parent) {\r\n        clone.self = false\r\n    }\r\n    return clone\r\n}\r\n","import { TreeNodeApi, replace, TreeNode } from \"@/node-tree/types\";\r\nimport { $pockets } from \"@/pockets\"\r\n\r\nexport let useReplace = (api: TreeNodeApi) : replace => {\r\n    let replace:replace = {\r\n        child(index: number, node: TreeNode){\r\n            $pockets.utils.object.set(api.node.nodes, index, node)\r\n        },\r\n        self: (node: TreeNode) => {\r\n            if(!api.parent || !api.parent.replace.child) return;\r\n            api.parent.replace.child(api.paths.index, node)\r\n        }\r\n    }\r\n    if(!api.parent) {\r\n        replace.self = false\r\n    }\r\n    if(!api.hasNodes) {\r\n        replace.child = false\r\n    }\r\n    return replace\r\n}","\r\nimport type { move, TreeNodeApi } from \"@/node-tree/types\"\r\n\r\nexport let useMove = (api:TreeNodeApi) : move => {\r\n    \r\n    let self = (to: number) => {\r\n        if(!api.parent || !api.parent.move.child) return false;\r\n        return api.parent.move.child(api.paths.index, to )\r\n    }\r\n    \r\n    let child = (from: number, to: number) : false => {\r\n        if(!api.parent || !api.parent.node.nodes) return false;\r\n        let element = api.parent.node.nodes[from];\r\n        api.parent.node.nodes.splice(from, 1);\r\n        api.parent.node.nodes.splice(to, 0, element);\r\n        return false\r\n    }\r\n\r\n\r\n    let move: move = {\r\n        self,\r\n        child,\r\n        left(){\r\n            if(!api.move.child) return false;\r\n            return api.move.child(api.paths.index, api.paths.index-1)\r\n        },\r\n        right(){\r\n            if(!api.move.child) return false;\r\n            return api.move.child(api.paths.index, api.paths.index+1)\r\n        }\r\n    }\r\n    if(api.paths.index==0) {\r\n        move.left = false;\r\n    }\r\n    if(!api.parent || !api.parent.node.nodes || api.paths.index == api.parent.node.nodes.length -1) {\r\n        move.right = false;\r\n    }\r\n    return move\r\n}\r\n","import { TreeNodeSchema, TreeNodeApi } from \"@/node-tree/types\"\r\n\r\nexport let useSchema = (api : TreeNodeApi) : TreeNodeSchema | false => {\r\n    return api.editor.nodes.list.find((entry: TreeNodeSchema) => {\r\n        return entry.node.schema == api.node.schema\r\n    } ) ?? false\r\n}","import { TreeNodeApi,  TreeNodeSchemaField } from \"@/node-tree/types\"\r\n\r\nexport let useEditFields = (api:TreeNodeApi) : Array<TreeNodeSchemaField> => {\r\n    \r\n    if(!api.schema || !api.node || !api.editor.nodes.fields) return []\r\n    \r\n    return api.editor.nodes.fields.filter((field: TreeNodeSchemaField) => {\r\n        if(!api.schema) return;\r\n        return api.schema.fields.includes(field.ID)\r\n    })\r\n\r\n}","import { $pockets } from \"@/pockets\"\r\nimport { TreeNodeApi, TreeNode, nodeHydrate } from \"@/node-tree/types\"\r\n\r\nlet createFetcher = (read: Array<string>, api : TreeNodeApi) => {\r\n    \r\n    return async (index: number) => {\r\n\r\n        let child = api.getChild(index)\r\n\r\n        if(!child.node) return;\r\n\r\n        try {\r\n            let newNode:TreeNode = await $pockets.crud('node-tree/node')\r\n                .init(child.node)\r\n                .read(read)\r\n            \r\n            child.replace.self(newNode)\r\n\r\n            return api.getChild(index)\r\n\r\n        } catch(e) {\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nexport let useInitializer = (api : TreeNodeApi) => {\r\n\r\n    let initializer = createFetcher(['initialize:<='], api)\r\n\r\n    let initialize:nodeHydrate = {\r\n        self: async () => {\r\n            if(!api.parent || !api.parent.initialize.child) return;\r\n            return api.parent.initialize.child(api.paths.index)\r\n        },\r\n        child: async (index: number) => initializer(index)\r\n    }    \r\n\r\n    if(!api.hasNodes) {\r\n        initialize.child = false\r\n    }\r\n\r\n    if(!api.parent) {\r\n        initialize.self = false\r\n    }\r\n\r\n    return initialize\r\n    \r\n}\r\n\r\nexport let useHydrater = (api : TreeNodeApi) => {\r\n\r\n    let hydrater = createFetcher(['hydrate:<='], api)\r\n\r\n    let hydrate:nodeHydrate = {\r\n        self: async () => {\r\n            if(!api.parent || !api.parent.hydrate.child) return;\r\n            return api.parent.hydrate.child(api.paths.index)\r\n        },\r\n        child: async (index: number) => hydrater(index),\r\n        active: async() => {\r\n            if(!api.hydrate.self) return;\r\n            /**\r\n                Active is meant to be used within an editor context only. \r\n            */\r\n            let node = await api.hydrate.self()\r\n            if(node ) api.editor.active = node\r\n        }\r\n    }   \r\n\r\n    if(!api.hasNodes) {\r\n        hydrate.child = false\r\n    }\r\n\r\n    if(!api.parent) {\r\n        hydrate.self = false\r\n    }\r\n\r\n    return hydrate\r\n\r\n}\r\n","import type { TreeNodeApiProps, createdApi, TreeNodeProxied, TreeNodeApi } from \"@/node-tree/types\"\r\n\r\nimport { reactive, computed } from \"vue\"\r\nimport { $pockets } from \"@/pockets\"\r\n\r\nimport { useAdd } from \"./add\"\r\nimport { useRemove } from \"./remove\"\r\nimport { useClone } from \"./clone\"\r\nimport { useReplace } from \"./replace\"\r\nimport { useMove } from \"./move\"\r\n\r\nimport { useSchema } from './schema'\r\nimport { useEditFields } from \"./edit-fields\"\r\n\r\nimport { useInitializer, useHydrater } from \"./crud\"\r\nimport { editor } from \"@/node-tree/editor\"\r\n\r\nexport let createTreeApi = (props:TreeNodeApiProps) : createdApi => {\r\n        \r\n    let getNodeApi = (node: TreeNodeProxied) : TreeNodeApi => {\r\n\r\n        let paths = computed(() => {\r\n            let sourcePath = [ props.source.metaKey, props.source.type, props.source.ID ].join('.')\r\n            let path =  node.__getPath\r\n            let index =  parseInt( path.split('.').slice(-1)[0] )\r\n            return {\r\n                full: [ sourcePath, path] .join('.'),\r\n                path,\r\n                index,\r\n            }\r\n        })\r\n\r\n        let getParent = (node) => {\r\n            let parent = node.__getParent(2)\r\n            if(parent) {\r\n                return getNodeApi(parent)\r\n            }\r\n            return false\r\n        }\r\n        \r\n        let parent = computed( () => getParent(node)  )\r\n\r\n        let hasNodes = computed(() => Array.isArray(api.node?.nodes) )\r\n\r\n        let getChild = (index: number) => {\r\n            if(!api.node.nodes) return;\r\n            return getNodeApi( api.node.nodes[index] as TreeNodeProxied)\r\n        }\r\n\r\n        let branch = computed( () => {\r\n            \r\n            let initial: Array<TreeNodeApi> = [];\r\n\r\n            /**\r\n                As the reducer is traversing from the source node upward,\r\n                the resutl must be reversed so that they are in the correct order\r\n                from top to bottom.\r\n            */\r\n            \r\n            return api.paths.path.split('.nodes.').reduce((acc, _, index) => {\r\n                acc.push( getNodeApi( api.node.__getParent( index  * 2 ) ) )\r\n                return acc;\r\n            }, initial ).reverse() \r\n\r\n        } )\r\n\r\n        let api:TreeNodeApi = reactive( {\r\n            \r\n            branch,\r\n            paths,\r\n            \r\n            getNodeApi,\r\n            getChild,\r\n\r\n            node,\r\n            hasNodes,\r\n            parent,\r\n\r\n            editor,\r\n            editFields: computed( () => useEditFields(api) ),\r\n            schema:     computed( () => useSchema(api) ),\r\n\r\n            add:        computed( () => useAdd(api) ),\r\n            remove:     computed( () => useRemove(api) ),\r\n            clone:      computed( () => useClone(api) ),\r\n            replace:    computed( () => useReplace(api) ),\r\n            move:       computed( () => useMove(api) ),\r\n\r\n            initialize: computed( () => useInitializer(api) ),\r\n            hydrate:    computed( () => useHydrater(api) )\r\n            \r\n        } )\r\n        \r\n        return api\r\n\r\n    }\r\n    \r\n    let saveTree = async () => await $pockets.crud('node-tree/root').init(props.source).update(props.root)\r\n\r\n    return {\r\n        saveTree,\r\n        getNodeApi,\r\n    }\r\n    \r\n}\r\n","import { defineComponent as _defineComponent } from 'vue'\nimport { unref as _unref, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nimport treeWalker from \"@/node-tree/walker\"\r\nimport { provide, onMounted } from \"vue\"\r\nimport { createTreeApi } from '@/node-tree/create-tree-api'\r\nimport { injectionKey } from \"@/node-tree/create-tree-api/injection-key\"\r\nimport ObservableSlim from \"observable-slim\"\r\n\r\n\nexport default /*#__PURE__*/_defineComponent({\n  __name: 'index',\n  props: {\r\n    root: {\r\n        type: Object,\r\n        required: true\r\n    },\r\n    source: {\r\n        type: Object,\r\n    }\r\n},\n  setup(__props) {\n\nconst $props = __props;\n\r\n\r\n\r\nlet props:any = ObservableSlim.create($props, false, (change) => {\r\n    console.log(change)\r\n})     \r\n\r\nlet api = createTreeApi(props)\r\n\r\nprovide(injectionKey, api )\r\n\r\nonMounted( () => $pockets.event.on('pockets/node-tree/save', api.saveTree) )\r\n\r\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createBlock(_unref(treeWalker), {\n    \"tree-node\": _unref(props).root\n  }, null, 8, [\"tree-node\"]))\n}\n}\n\n})","import script from \"./index.vue?vue&type=script&lang=ts&setup=true\"\nexport * from \"./index.vue?vue&type=script&lang=ts&setup=true\"\n\nconst __exports__ = script;\n\nexport default __exports__"],"names":["ObservableSlim","paths","observables","targets","targetsProxy","dupProxy","_getProperty","obj","path","split","reduce","prev","curr","undefined","self","_create","target","domDelay","originalObservable","originalPath","observable","push","Array","hasOwnProperty","__length","length","Object","defineProperty","enumerable","value","writable","changes","_getPath","property","jsonPointer","fullPath","lastTarget","i","isNaN","indexOf","substring","replace","_notifyObservers","numChanges","paused","domDelayIsNumber","setTimeout","changesCopy","slice","observers","handler","get","parentPath","splice","parentProxy","join","targetProp","Date","Function","bind","__isProxy","__getTarget","__targetPosition","ttp","l","proxy","newPath","deleteProperty","originalChange","previousValue","assign","changesPaused","a","currentTargetProxy","b","set","receiver","foundObservable","typeOfTargetProp","type","targetPosition","z","parentTarget","keys","stillExists","iterate","nestedTarget","objProp","c","d","configurable","Proxy","proxyItem","create","observer","this","observe","pause","foundMatch","Error","resume","pauseChanges","resumeChanges","remove","matchedObservable","module","exports","err","editor","reactive","show","mode","nodes","list","fields","active","selectedNodes","save","$pockets","modeLocked","computed","sfc","props","__vccOpts","key","val","render","_ctx","_cache","$props","$setup","$data","$options","_directive_tooltip","_resolveDirective","_withDirectives","_openBlock","_createBlock","_resolveDynamicComponent","treeNode","el","_mergeProps","class","classes","onClick","_withModifiers","clickHandler","onMouseenter","$event","hoverHandler","onMouseleave","default","_withCtx","_createElementBlock","_Fragment","_renderList","node","_","toolTip","injectionKey","Symbol","useInject","resolved","inject","setup","disabled","state","selected","nodeApi","getNodeApi","e","full","childOfselected","includes","hovered","content","branch","map","schema","title","shown","triggers","placement","popperClass","delay","disableInteractions","String","data","name","__exports__","useAdd","api","inside","index","after","parent","add","before","hasNodes","useRemove","child","useClone","clone","getChild","targetIndex","useReplace","useMove","to","move","from","element","left","right","useSchema","find","entry","useEditFields","filter","field","ID","createFetcher","read","async","newNode","init","useInitializer","initializer","initialize","useHydrater","hydrater","hydrate","createTreeApi","sourcePath","source","metaKey","__getPath","parseInt","getParent","__getParent","isArray","initial","acc","reverse","editFields","saveTree","update","root","_defineComponent","__name","required","__props","change","console","log","provide","onMounted","event","on","_unref","treeWalker"],"sourceRoot":""}